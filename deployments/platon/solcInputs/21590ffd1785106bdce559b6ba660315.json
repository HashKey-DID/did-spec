{
  "language": "Solidity",
  "sources": {
    "contracts/base58.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Base58 {\n    bytes constant ALPHABET =\n        \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n    /**\n     * @notice encode is used to encode the given bytes in base58 standard.\n     * @param data_ raw data, passed in as bytes.\n     * @return base58 encoded data_, returned as bytes.\n     */\n    function encode(bytes memory data_) public pure returns (bytes memory) {\n        unchecked {\n            uint256 size = data_.length;\n            uint256 zeroCount;\n            while (zeroCount < size && data_[zeroCount] == 0) {\n                zeroCount++;\n            }\n            size = zeroCount + ((size - zeroCount) * 8351) / 6115 + 1;\n            bytes memory slot = new bytes(size);\n            uint32 carry;\n            int256 m;\n            int256 high = int256(size) - 1;\n            for (uint256 i = 0; i < data_.length; i++) {\n                m = int256(size - 1);\n                for (carry = uint8(data_[i]); m > high || carry != 0; m--) {\n                    carry = carry + 256 * uint8(slot[uint256(m)]);\n                    slot[uint256(m)] = bytes1(uint8(carry % 58));\n                    carry /= 58;\n                }\n                high = m;\n            }\n            uint256 n;\n            for (n = zeroCount; n < size && slot[n] == 0; n++) {}\n            size = slot.length - (n - zeroCount);\n            bytes memory out = new bytes(size);\n            for (uint256 i = 0; i < size; i++) {\n                uint256 j = i + n - zeroCount;\n                out[i] = ALPHABET[uint8(slot[j])];\n            }\n            return out;\n        }\n    }\n\n    /**\n     * @notice decode is used to decode the given string in base58 standard.\n     * @param data_ data encoded with base58, passed in as bytes.\n     * @return raw data, returned as bytes.\n     */\n    function decode(bytes memory data_) public pure returns (bytes memory) {\n        unchecked {\n            uint256 zero = 49;\n            uint256 b58sz = data_.length;\n            uint256 zcount = 0;\n            for (uint256 i = 0; i < b58sz && uint8(data_[i]) == zero; i++) {\n                zcount++;\n            }\n            uint256 t;\n            uint256 c;\n            bool f;\n            bytes memory binu = new bytes(2 * (((b58sz * 8351) / 6115) + 1));\n            uint32[] memory outi = new uint32[]((b58sz + 3) / 4);\n            for (uint256 i = 0; i < data_.length; i++) {\n                bytes1 r = data_[i];\n                (c, f) = indexOf(ALPHABET, r);\n                require(f, \"invalid base58 digit\");\n                for (int256 k = int256(outi.length) - 1; k >= 0; k--) {\n                    t = uint64(outi[uint256(k)]) * 58 + c;\n                    c = t >> 32;\n                    outi[uint256(k)] = uint32(t & 0xffffffff);\n                }\n            }\n            uint64 mask = uint64(b58sz % 4) * 8;\n            if (mask == 0) {\n                mask = 32;\n            }\n            mask -= 8;\n            uint256 outLen = 0;\n            for (uint256 j = 0; j < outi.length; j++) {\n                while (mask < 32) {\n                    binu[outLen] = bytes1(uint8(outi[j] >> mask));\n                    outLen++;\n                    if (mask < 8) {\n                        break;\n                    }\n                    mask -= 8;\n                }\n                mask = 24;\n            }\n            for (uint256 msb = zcount; msb < binu.length; msb++) {\n                if (binu[msb] > 0) {\n                    return slice(binu, msb - zcount, outLen);\n                }\n            }\n            return slice(binu, 0, outLen);\n        }\n    }\n\n    /**\n     * @notice encodeToString is used to encode the given byte in base58 standard.\n     * @param data_ raw data, passed in as bytes.\n     * @return base58 encoded data_, returned as a string.\n     */\n    function encodeToString(bytes memory data_) public pure returns (string memory) {\n        return string(encode(data_));\n    }\n\n    /**\n     * @notice encodeFromString is used to encode the given string in base58 standard.\n     * @param data_ raw data, passed in as a string.\n     * @return base58 encoded data_, returned as bytes.\n     */\n    function encodeFromString(string memory data_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return encode(bytes(data_));\n    }\n\n    /**\n     * @notice decode is used to decode the given string in base58 standard.\n     * @param data_ data encoded with base58, passed in as string.\n     * @return raw data, returned as bytes.\n     */\n    function decodeFromString(string memory data_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return decode(bytes(data_));\n    }\n\n    /**\n     * @notice slice is used to slice the given byte, returns the bytes in the range of [start_, end_)\n     * @param data_ raw data, passed in as bytes.\n     * @param start_ start index.\n     * @param end_ end index.\n     * @return slice data\n     */\n    function slice(\n        bytes memory data_,\n        uint256 start_,\n        uint256 end_\n    ) public pure returns (bytes memory) {\n        unchecked {\n            bytes memory ret = new bytes(end_ - start_);\n            for (uint256 i = 0; i < end_ - start_; i++) {\n                ret[i] = data_[i + start_];\n            }\n            return ret;\n        }\n    }\n\n    /**\n     * @notice indexOf is used to find where char_ appears in data_.\n     * @param data_ raw data, passed in as bytes.\n     * @param char_ target byte.\n     * @return index, and whether the search was successful.\n     */\n    function indexOf(bytes memory data_, bytes1 char_)\n        public\n        pure\n        returns (uint256, bool)\n    {\n        unchecked {\n            for (uint256 i = 0; i < data_.length; i++) {\n                if (data_[i] == char_) {\n                    return (i, true);\n                }\n            }\n            return (0, false);\n        }\n    }\n}"
    },
    "contracts/reslover.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"./base58.sol\";\n\ncontract DIDDocument {\n    // lib\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\n    // event\n    event DIDCreateDID(string,string);\n    event DIDUpdateVerificationMethod(string,string);\n    event DIDAddVerificationMethod(string,string);\n    event DIDAddContext(string,string);\n    event DIDDeleteContext(string,string);\n    event DIDAddAuthentication(string,string);\n    event DIDDeleteAuthentication(string,string);\n    event DIDAddAssertion(string,string);\n    event DIDDeleteAssertion(string,string);\n    event DIDAddController(string,string);\n    event DIDDeleteController(string,string);\n    event DIDDeleteDID(string);\n\n    // todo 是否需要公钥 modifier\n    modifier authenticate(string memory did, bytes memory sig) {\n        require(didExist[did], \"did not exist\");\n        bytes32 controller = keccak256(getDid(msg.sender));\n        require(controllerSet[did].contains(controller), \"not controller\");\n        // \n        bytes memory pk = controllerPKs[controller];\n        address controllerAddr = publicKey2Addr(pk);\n        require(_validate(sha256(bytes(did)), sig, controllerAddr));\n        _;\n    }\n\n    modifier exist(string memory did) {\n        require(didExist[did], \"did not exist\");\n        _;\n    }\n\n    // did -> bool\n    mapping(string => bool) public didExist;\n\n    // did -> context[]\n    mapping(string => EnumerableSetUpgradeable.Bytes32Set) contextSet;\n    mapping(bytes32 => bytes) public contexts;\n    \n    // did -> controller\n    mapping(string => EnumerableSetUpgradeable.Bytes32Set) controllerSet;\n    mapping(bytes32 => string) public controllers;\n    mapping(bytes32 => bytes) public controllerPKs;\n    \n    // did -> verificationMethods\n    mapping(string => mapping(bytes32 => bytes)) public verificationMethods;\n    mapping(string => EnumerableSetUpgradeable.Bytes32Set) verificationMethodIds;\n    \n    // authentication\n    mapping(string => EnumerableSetUpgradeable.Bytes32Set) authenticationSet;\n    mapping(bytes32 => bytes) public authentications;\n    \n    // todo assertion\n    mapping(string => EnumerableSetUpgradeable.Bytes32Set) assertionSet;\n    mapping(bytes32 => bytes) public assertions;\n\n    // 1. only publicKey paramater\n    function create(\n        bytes calldata publicKey,\n        string memory controller,\n        bytes calldata controllerPublicKey\n    ) public {\n        address addr = publicKey2Addr(publicKey);\n        bytes memory didBytes = getDid(addr);\n        string memory did = string(didBytes);\n        require(!didExist[did], \"did already exist\");\n\n        // bytes memory vmType = bytes(\"EcdsaSecp256k1VerificationKey2019\");\n        // bytes memory vmId;\n        // bytes memory vmPK;\n        addContext(did, bytes(\"https://www.w3.org/ns/did/v1\"));\n        // addContext(did, bytes(\"https://w3id.org/security/suites/secp256k1-2019\"));\n\n        //todo \n        if (!checkDidFormat(controller)) {\n            // controller not exist\n            // vmId = bytes.concat(didBytes, bytes(\"#controller\"));\n            // vmPK = bytes.concat(bytes(\"z\"), Base58.encode(publicKey));\n            addController(did, did, publicKey);\n\n            // controllers[did] = did;\n            // did2ControllerPK[did] = publicKey;\n            // operateVerificationMethod(did, vmId, vmType, didBytes, bytes(\"publicKeyMultibase\"), vmPK);\n        } else {\n            // controller exist\n            // vmId = bytes.concat(bytes(controller), bytes(\"#controller\"));\n            // vmPK = bytes.concat(bytes(\"z\"), Base58.encode(controllerPublicKey));\n            addController(did, controller, controllerPublicKey);\n           \n            // controllers[did] = controller;\n            // did2ControllerPK[did] = controllerPublicKey;\n            // operateVerificationMethod(did, vmId, vmType, bytes(controller), bytes(\"publicKeyMultibase\"), vmPK);\n        }\n        // add authentication\n        // addAuthentication(did, vmId);\n        \n        didExist[did] = true;\n        emit DIDCreateDID(did, controllers[keccak256(didBytes)]);\n    }\n\n    /// \n    function addController(string memory did, string memory controller, bytes memory controllerPublicKey) internal {\n        bytes32 controllerB32 = keccak256(bytes(controller));\n        if (controllerSet[did].contains(controllerB32)) {\n            return;\n        }\n        // \n        controllerSet[did].add(controllerB32);\n        controllers[controllerB32] = controller;\n        controllerPKs[controllerB32] = controllerPublicKey;\n        emit DIDAddController(did, controller);\n    }\n\n    function addController(string memory did, string memory controller, bytes memory controllerPublicKey, bytes memory sig) public authenticate(did, sig) {\n        require(controllerSet[did].contains(keccak256(bytes(controller))), \"already exist\");\n        addController(did, controller, controllerPublicKey);\n        emit DIDAddController(did, controller);\n    }\n\n    // \n    function deleteController(string memory did, string memory controller, bytes memory sig) public authenticate(did, sig) {\n        bytes32 controllerB32 = keccak256(bytes(controller));\n        require(!controllerSet[did].contains(controllerB32), \"not exist\");\n        //\n        controllerSet[did].remove(controllerB32);\n        controllers[controllerB32] = \"\";\n        controllerPKs[controllerB32] = bytes(\"\");\n        //\n        emit DIDDeleteController(did, controller);\n    }\n\n    // \n    function readController(string memory did) public view exist(did) returns (string memory) {\n        bytes memory ctBytes = bytes(\"[\");\n        // \n        EnumerableSetUpgradeable.Bytes32Set storage _controllerSet = controllerSet[did];\n        for (uint256 i=0; i<_controllerSet.length(); i++){\n           ctBytes = bytes.concat(ctBytes, bytes('\\\"'), contexts[_controllerSet.at(i)] , bytes('\\\",'));\n        }\n        ctBytes[ctBytes.length-1] = bytes1(\"]\");\n        return string(ctBytes);\n    }\n\n    // context\n    function addContext(string memory did, bytes memory ctx) internal {\n        bytes32 ctxHash = keccak256(ctx);\n        if (contextSet[did].contains(ctxHash)){\n            return;\n        }\n        contextSet[did].add(ctxHash);\n        contexts[ctxHash] = ctx;\n        emit DIDAddContext(did, string(ctx));\n    }\n\n    function addContext(string memory did, string memory ctx, bytes memory sig) public authenticate(did, sig) {\n        addContext(did, bytes(ctx));\n    }\n\n    function deleteContext(string memory did, string memory ctx, bytes memory sig) public authenticate(did, sig) {\n        bytes32 ctxHash = keccak256(bytes(ctx));\n       \n       require(contextSet[did].contains(ctxHash), \"ctx not exist\");\n       contextSet[did].remove(ctxHash);\n       emit DIDDeleteContext(did, string(ctx));\n    }\n\n    function readContext(string memory did) public view exist(did) returns (string memory) {\n        bytes memory ctBytes = bytes(\"[\");\n        // \n        EnumerableSetUpgradeable.Bytes32Set storage _contextSet = contextSet[did];\n        for (uint256 i=0; i<_contextSet.length(); i++){\n           ctBytes = bytes.concat(ctBytes, bytes('\\\"'), contexts[_contextSet.at(i)] , bytes('\\\",'));\n        }\n        ctBytes[ctBytes.length-1] = bytes1(\"]\");\n        return string(ctBytes);\n    }\n\n    // authentication\n    function addAuthentication(string memory did, bytes memory auth) internal {\n        bytes32 authHash = keccak256(bytes(auth));\n\n        // VerificationMethod id must exist.\n        if (authenticationSet[did].contains(authHash) && verificationMethodIds[did].contains(authHash)){\n            return;\n        }\n        authenticationSet[did].add(authHash);\n        authentications[authHash] = auth;\n        emit DIDAddAuthentication(did, string(auth));\n    }\n\n    function addAuthentication(string memory did, string memory auth, bytes memory sig) public authenticate(did, sig){\n        addAuthentication(did, bytes(auth));\n    }\n\n    function deleteAuthentication(string memory did, string memory auth, bytes memory sig) public authenticate(did, sig) {\n       bytes32 authHash = keccak256(bytes(auth));\n       \n       require(authenticationSet[did].contains(authHash), \"authentication not exist\");\n       authenticationSet[did].remove(authHash);\n       emit DIDDeleteAuthentication(did, string(auth));\n    }\n\n    function readAuthentication(string memory did) public view exist(did) returns (string memory) {\n        bytes memory authBytes = bytes(\"[\");\n        // \n        EnumerableSetUpgradeable.Bytes32Set storage _authenticationSet = authenticationSet[did];\n        for (uint256 i=0; i<_authenticationSet.length(); i++){\n           authBytes = bytes.concat(authBytes, bytes('\\\"'), authentications[_authenticationSet.at(i)] , bytes('\\\",'));\n        }\n        authBytes[authBytes.length-1] = bytes1(\"]\");\n        return string(authBytes);\n    }\n\n    // assertion\n    function addAssertion(string memory did, bytes memory auth) internal {\n        bytes32 authHash = keccak256(bytes(auth));\n\n        // VerificationMethod id must exist.\n        if (assertionSet[did].contains(authHash) && verificationMethodIds[did].contains(authHash)) {\n            return;\n        }\n        assertionSet[did].add(authHash);\n        assertions[authHash] = auth;\n        emit DIDAddAssertion(did, string(auth));\n    }\n\n    function addAssertion(string memory did, string memory auth, bytes memory sig) public authenticate(did, sig) {\n        addAssertion(did, bytes(auth));\n    }\n\n    function deleteAssertion(string memory did, string memory auth, bytes memory sig) public authenticate(did, sig) {\n       bytes32 authHash = keccak256(bytes(auth));\n       \n       require(assertionSet[did].contains(authHash), \"authentication not exist\");\n       assertionSet[did].remove(authHash);\n       emit DIDDeleteAssertion(did, string(auth));\n    }\n\n    function readAssertion(string memory did) public view exist(did) returns (string memory) {\n        bytes memory assertBytes = bytes(\"[\");\n        // \n        EnumerableSetUpgradeable.Bytes32Set storage _assertionSet = assertionSet[did];\n        for (uint256 i=0; i<_assertionSet.length(); i++){\n           assertBytes = bytes.concat(assertBytes, bytes('\\\"'), assertions[_assertionSet.at(i)] , bytes('\\\",'));\n        }\n        assertBytes[assertBytes.length-1] = bytes1(\"]\");\n        return string(assertBytes);\n    }\n\n    // add/update VerificationMethod\n    function operateVerificationMethod(string memory did, bytes memory vmId, bytes memory vmType, bytes memory controller, bytes memory pkKey, bytes memory pkValue) internal {\n        bytes memory b1 = bytes.concat(bytes('{\\\"id\\\": \\\"'), vmId, bytes('\\\",'));\n        bytes memory b2 = bytes.concat(bytes('\\\"type\\\": \\\"'), vmType, bytes('\\\",'));\n        bytes memory b3 = bytes.concat(bytes('\\\"controller\\\": \\\"'), controller, bytes('\\\",'));\n        bytes memory b4 = bytes.concat(bytes('\\\"'), pkKey, bytes('\\\": \\\"'), pkValue, bytes('\\\"}'));\n        bytes memory vm = bytes.concat(b1, b2, b3, b4);\n\n        bytes32 vmIdHash = sha256(vmId);\n        if (verificationMethodIds[did].contains(vmIdHash)) {\n            emit DIDUpdateVerificationMethod(did, string(vm));\n        } else {\n            verificationMethodIds[did].add(vmIdHash);\n            emit DIDAddVerificationMethod(did, string(vm));\n        }\n        verificationMethods[did][vmIdHash] = vm;\n    }\n    \n    function operateVerificationMethod(string memory did, string memory vmId, string memory vmType, string memory controller, string memory pkKey, string memory pkValue, bytes memory sig) public authenticate(did, sig) {\n        operateVerificationMethod(did, bytes(vmId), bytes(vmType), bytes(controller), bytes(pkKey), bytes(pkValue));\n    }\n\n    function deleteVerificationMethod(string memory did,string memory vmId, bytes memory sig) public authenticate(did, sig) {\n        bytes32 vmIdHash = sha256(bytes(vmId));\n        require(verificationMethodIds[did].contains(vmIdHash), \"VerificationMethod Id not exist\");\n        verificationMethodIds[did].remove(vmIdHash);\n        verificationMethods[did][vmIdHash] = bytes(\"\");\n    }\n\n    function readVerificationMethod(string memory did) public view exist(did) returns (string memory) {\n        bytes memory verificationBytes = bytes(\"[\");\n        EnumerableSetUpgradeable.Bytes32Set storage vms = verificationMethodIds[did];\n        for(uint i=0; i < vms.length(); i++){\n            bytes memory pk = verificationMethods[did][vms.at(i)];\n            verificationBytes = bytes.concat(verificationBytes, pk, bytes(','));\n        }\n        verificationBytes[verificationBytes.length-1] = bytes1(\"]\");\n        return string(verificationBytes);\n    }\n\n    function resolve(string memory did) public exist(did) view returns (string memory){\n        bytes memory document = bytes(\"{\");\n        document = bytes.concat(document, bytes('\\\"@context\\\":'), bytes(readContext(did)), bytes(','));\n        document = bytes.concat(document, bytes('\\\"id\\\":'), bytes('\\\"'),bytes(did), bytes('\\\",'));\n        document = bytes.concat(document, bytes('\\\"controller\\\":'), bytes('\\\"'),bytes(readController(did)), bytes('\\\",'));\n        document = bytes.concat(document, bytes('\\\"verificationMethod\\\":'), bytes(readVerificationMethod(did)), bytes(','));\n        document = bytes.concat(document, bytes('\\\"authentication\\\":'), bytes(readAuthentication(did)), bytes(','));\n        document[document.length-1] = bytes1(\"}\");\n        return string(document);\n    }\n\n    function revoke(string memory did, bytes memory sig) authenticate(did, sig) public {\n        didExist[did] = false;\n        emit DIDDeleteDID(did);\n    }\n\n    // todo\n    function checkDidFormat(string memory did) public pure returns (bool) {\n        // did:hashkey:0xb9c5714089478a327f09197987f16f9e5d936e8a\n        if (bytes(did).length != 52) {\n            return false;\n        }\n        return true;\n    }\n\n    function getDid(address addr) public pure returns(bytes memory) {\n        return bytes(string.concat(\"did:hsk:\", toString(addr)));\n    }\n\n    function publicKey2Addr(bytes memory publicKey) public pure returns(address){\n        address addr = address(uint160(uint256(keccak256(publicKey))));\n        return addr;\n    }\n\n    function _validate(bytes32 message, bytes memory signature, address signer_) internal pure returns (bool) {\n        require(signer_ != address(0) && signature.length == 65);\n        bytes32 r;\n        bytes32 s;\n        uint8 v = uint8(signature[64]) + 27;\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n        }\n        return ecrecover(message, v, r, s) == signer_;\n    }\n\n    function _toBytes(address a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            a := and(a, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            mstore(\n                add(m, 20),\n                xor(0x140000000000000000000000000000000000000000, a)\n            )\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n    }\n\n    function toString(address account) public pure returns(string memory) {\n        return toString(abi.encodePacked(account));\n    }\n\n    function toString(bytes memory data) public pure returns(string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(data.length * 2);\n        for (uint i = 0; i < data.length; i++) {\n            str[i*2] = alphabet[uint(uint8(data[i] >> 4))];\n            str[1+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n}\n\n\n\n\n\n\n\n\n\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}